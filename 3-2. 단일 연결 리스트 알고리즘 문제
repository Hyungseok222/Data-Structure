#include<iostream>
#include<cstring>
#include<fstream>
#include<sstream>
#include<cstdlib>

using namespace std;

/*단어 수 세기 프로그램*/

enum BOOL { FALSE, TRUE };

typedef struct _node Node;
struct _node {
	char data[80];
	Node* next;
};

typedef struct _list {
	Node* head; 
	Node* tail; 
	int size; 
}List;


BOOL createList(List* lp); 
BOOL addFirst(List* lp, char data); 
BOOL addLast(List* lp, char data);
void displayList(List* lp);
Node* searchNode(List* lp, char data);
BOOL removeNode(List* lp, char data);
void sortList(List* lp);
void destroyList(List* lp);

BOOL dataFileLoad(List* lp);


/*==============================================================*/


int main() {
	List list;
	size_t tot_length = 0;
	int tot_cnt = 0;
	Node* curp;
	BOOL bres;


	bres = createList(&list);
	if (bres == FALSE) {
		cout << "리스트 초기화 실패" << endl;
		return 0;
	}

	bres = dataFileLoad(&list);
	if (bres == FALSE) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	sortList(&list);
	
	curp = list.head->next;

	while (curp != list.tail) {
		tot_length += strlen(curp->data);
		tot_cnt++;
		cout << tot_cnt << "번째 단어:" << curp->data << endl;
		curp = curp->next;
	}


	cout << "전체 단어의 개수:" << tot_cnt << ", " << "평균 단어길이:" << tot_length << endl;

	destroyList(&list);

	return 0;
}



/*==============================================================*/


BOOL createList(List* lp) {
	if (lp == NULL) { 
		return FALSE;
	}


	lp->head = (Node*)malloc(sizeof(Node)); 
	lp->tail = (Node*)malloc(sizeof(Node)); 

	if (lp->head == NULL || lp->tail == NULL) {
		free(lp->head);
		free(lp->tail);
		return FALSE;
	}

	/*head tail 연결*/
	lp->head->next = lp->tail;
	lp->tail->next = lp->tail;


	lp->size = 0; 


	return TRUE;
}


BOOL addFirst(List* lp, const char* data) {
	Node* newp; 

	if (lp == NULL) { 
		return FALSE;
	}

	newp = (Node*)malloc(sizeof(Node)); 
	if (newp != NULL) {
		strcpy_s(newp->data, data);
		newp->next = lp->head->next; 
		lp->head->next = newp; 
		lp->size = lp->size + 1; 
		return TRUE;
	}
	else {
		return FALSE;
	}
}


BOOL addLast(List* lp, const char* data) {
	Node* newp; // 새 노드
	Node* btp; // tail노드 앞 노드

	if (lp == NULL) {
		return FALSE;
	}

	newp = (Node*)malloc(sizeof(Node));// 동적할당
	if (newp != NULL) {
		strcpy_s(newp->data, data);
		newp->next = lp->tail; // tail이 가리키는 주소가 아니라, 그냥 tail의 주소 - addFirst함수와의 차이점
		//tail노드 앞 노드 검색
		//tail노드 앞에 새 노드 연결
		btp = lp->head; //btp를 첫 노드인 head노드로 설정
		while (btp->next != lp->tail) {
			btp = btp->next; //btp는 head의 주소, btp->next 는 head가 가리키는 노드의 주소
		}
		btp->next = newp; //btp가 tail전 노드가 됨
		++lp->size;
		return TRUE;
	}
	else {
		return FALSE;
	}
}


void displayList(List* lp) {
	Node* crnt;

	if (lp == NULL) {
		return;
	}

	crnt = lp->head->next; // 이렇게 해야 crnt = head Node가 됨.
	while (crnt != lp->tail) { //crnt->next 가 가리키는 곳부터 data가 있음.
		cout << crnt->data << endl;
		crnt = crnt->next; // 다음 노드로 넘겨주는 코드
	}
	cout << endl;
	return;
}


Node* searchNode(List* lp, const char* data) {
	Node* curp;

	if (lp == NULL) {
		return NULL;
	}

	curp = lp->head->next;

	while (curp != lp->tail) {
		if (strcmp(curp->data,data) == 0) { // strcmp에서 문자가 같으면 0을 반환함
			return curp;
		}
		else {
			curp = curp->next;
		}
	}
	return NULL;
}


BOOL removeNode(List* lp, char data) {
	Node* dp;
	Node* curp;

	if (lp == NULL) {
		return FALSE;
	}

	dp = searchNode(lp, data);

	if (dp != NULL) {
		curp = lp->head;

		while (curp->next != dp) {
			curp = curp->next;
		}

		curp->next = dp->next;
		free(dp);
		--lp->size;
		return TRUE;
	}
	else {
		return FALSE;
	}
}


void sortList(List* lp) {
	Node* curp;
	Node* np;

	char temp[80];

	if (lp == NULL) {
		return;
	}

	curp = lp->head->next;

	while (curp->next != lp->tail) {
		np = curp->next; // 계속 바뀌는 값이므로 while문 안에 만들어줘야함
		while (np != lp->tail) {
			if (strcmp(curp->data,np->data)>0) { //앞 문자가 뒤 문자보다 뒤로 가야할때
				strcpy_s(temp, np->data);
				strcpy_s(np->data, curp->data);
				strcpy_s(curp->data, temp);
			}
			np = np->next;
		}
		curp = curp->next;
	}
	return;
}


void destroyList(List* lp) {
	Node* curp;
	Node* temp;

	if (lp == NULL) {
		return;
	}

	curp = lp->head->next;
	while (curp != lp->tail) {
		temp = curp->next;
		free(curp);
		curp = temp;
	}
	free(lp->head);
	free(lp->tail);

	lp->head = lp->tail = NULL;
	lp->size = 0;
	return;
}

BOOL dataFileLoad(List* lp) {
	ifstream fp("test.txt");
	if (!fp) {
		return FALSE;
	}

	char word[80];
	while (fp >> word) {
		Node* resp = searchNode(lp, word);
		if (resp == NULL) { // 중복되는게 없을때
			addLast(lp, word);
		}
	}
	fp.close();
	return TRUE;
}
