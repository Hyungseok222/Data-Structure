#include <iostream>
#include <fstream>
#include <string>

/*리스트 스택 이용하기*/

using namespace std;

typedef struct _node Node;
struct _node {
	char data;
	Node* next;
};


typedef struct _stacknode{
	Node* head;
	Node* tail;
}Stack;


bool createStack(Stack* sp);
bool isStackEmpty(const Stack* sp);
bool push(Stack *sp, char inData);
bool pop(Stack *sp, char* popData);
void printStack(const Stack *sp);
void destroyStack(Stack *sp);



int main() {
	Stack lstk, rstk;
	createStack(&lstk);
	createStack(&rstk);
	char data; //pop에서 전달되는 문자 저장용도
	char delData;


	/*파일 입출력 부분*/

	ifstream inFile("file.txt");
	if (!inFile) {
		cout << "파일을 열 수 없습니다." << endl;
		return 1;
	}

	char word[1000];
	inFile.getline(word, sizeof(word));
	for (int j = 0; j < 4; j++) {
		cout << word[j] << endl; // 읽어오기 성공
		push(&lstk, word[j]);
	}

	int arraySize;
	inFile >> arraySize;
	inFile.ignore();


	char* array = new char[arraySize];

	for (int i = 0; i < arraySize; i++) {
		inFile >> array[i];
		// 여기에 들어오는 문자에 따라 함수 실행하도록 코드짜기
		if (array[i] == 'L') { // 커서가 왼쪽으로 이동
			cout << "L이 읽어짐" << endl;
			pop(&lstk, &data);
			push(&rstk, data);
		}
		else if (array[i] == 'D') {// 커서가 오른쪽으로 이동
			cout << "D가 읽어짐" << endl;
			pop(&rstk, &data);
			push(&lstk, data);
		}
		else if (array[i] == 'B') {
			cout << "B가 읽어짐" << endl;
			pop(&lstk, &delData);
		}
		else {
			break;
		}
	}
	cout << "========================= 편집 결과 ===========================" << endl;
	printStack(&lstk);  // b가 출력됨
	printStack(&rstk);

	
	destroyStack(&lstk);
	destroyStack(&rstk);
	delete[] array;
	return 0;
}


bool createStack(Stack* sp) {
	if (sp == NULL) {
		return false;
	}

	sp->head = new Node;
	sp->tail = new Node;
	
	if (sp->head == NULL || sp->tail == NULL) {
		free(sp->head);
		free(sp->tail);
		return false;
	}
	else {
		sp->head->next = sp->tail;
		sp->tail->next = sp->tail;
		cout << "스택 메모리 생성 성공!" << endl;
		return true;
	}
}

bool isStackEmpty(const Stack* sp) {
	if (sp == NULL) {
		return false;
	}

	if (sp->head->next == sp->tail) {
		return true;
	}
	else {
		return false;
	}
}

bool push(Stack* sp, char inData) {
	Node* newp;
	if (sp == NULL) {
		return false;
	}
	newp = new Node;

	if (newp != NULL) {
		newp->data = inData;
		newp->next = sp->head->next;

		sp->head->next = newp;
		cout << "push 진행" << endl;

		return true;
	}
	else {
		return false;
	}
}

bool pop(Stack* sp, char* popData) {
	Node* temp;

	if (sp == NULL) {
		return false;
	}

	if (isStackEmpty(sp) == true) {
		return false;
	}

	temp = sp->head->next;
	*popData = temp->data;
	sp->head->next = temp->next;
	delete temp; // Use 'delete' instead of 'free'
	cout << "pop실행" << endl;

	return true;
}

void printStack(const Stack* sp) {
	Node* curp;

	if (sp == NULL) {
		return;
	}
	if (isStackEmpty(sp) == true) {
		cout << "Stack이 비어있습니다." << endl;
		return;
	}

	curp = sp->head->next;
	while (curp != sp->tail) {
		cout << curp->data << endl;
		curp = curp->next;
	}
	return;
}

void destroyStack(Stack* sp) {
	Node* curp;
	Node* temp;

	if (sp == NULL) {
		return;
	}

	curp = sp->head->next;
	while (curp != sp->tail) {
		temp = curp->next;
		delete curp;
		curp = temp;
	}
	delete sp->head;
	delete sp->tail;

	sp->head = sp->tail = NULL;
	return;
}
