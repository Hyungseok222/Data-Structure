// 단일 연결리스트 생성해보기 (creatList(List *lp))

#include<iostream>

using namespace std;


// 구조체, 노드 선언 라인

enum BOOL { FALSE, TRUE };

typedef struct _node Node; //형변환 - _node 구조체를 Node 라는 단어로 사용하겠다!
struct _node {
	int data;
	Node* next;
};

typedef struct _list {
	Node* head; // data, next를 가진 구조체
	Node* tail; // data, next를 가진 구조체
	int size; // Node 수
}List;



// 함수 선언 라인

BOOL createList(List* lp); // List구조체로 만들어지는 리스트의 주소를 받음
BOOL addFirst(List* lp, int data); // Node 생성 후 list에 추가하는 함수
BOOL addLast(List* lp, int data);
void displayList(List* lp);





int main() {
	const char* menulist[] = { "1. 입력하기","2. 출력하기","3. 검색하기","4. 삭제하기","5. 정렬하기","6. 종 료" };
	int menuNum; // 메뉴 번호 저장 변수
	int menuCnt; // 매뉴 개수 저장변수
	menuCnt = sizeof(menulist) / sizeof(menulist[0]);

	List list;
	BOOL bres = createList(&list);
	if (bres == TRUE) {
		cout << "# list 생성 성공!" << endl;
	}
	else {
		cout << "# list 성공 실패" << endl;
	}

	for (int i = 0; i < menuCnt; i++) {
		cout << menulist[i] << endl;
	}



	while (TRUE) {
		cout << "입력하기:";
		cin >> menuNum;

		if (menuNum == 1) {
			int i;
			int data;
			for (i = 0; i < 5; i++) {
				cout << "추가할 데이터 입력:";
				cin >> data;
				addLast(&list, data);
			}
			continue;

		}
		else if (menuNum == 2) {
			displayList(&list);
		}
		else if (menuNum == 3) {

		}
		else if (menuNum == 4) {

		}
		else if (menuNum == 5) {

		}
		else if (menuNum == 6) {
			break;
		}
	}


}






BOOL createList(List* lp) {
	if (lp == NULL) {   // lp포인터 NULL check - 주소가 있는건지 없는건지 확인
		return FALSE;
	}


	lp->head = (Node*)malloc(sizeof(Node)); // List구조체의 head 원소에 접근하면서 head Node 생성
	lp->tail = (Node*)malloc(sizeof(Node)); // tail Node 생성 (구조체 동적할당)
	//malloc함수 특성상, 동적할당에 실패하면 NULL을 반환함, 따라서 실패했으면, FALSE를 반환하도록 해야함
	if (lp->head == NULL || lp->tail == NULL) {
		free(lp->head);
		free(lp->tail);
		return FALSE;
	}


	/*head tail 연결*/
	lp->head->next = lp->tail; // tail 주소를 head가 가리키도록 설정
	lp->tail->next = lp->tail;/*tail node의 포인터는 자기 자신을 가리키도록 설정*/


	lp->size = 0; // 연결리스트 크기 0 으로 초기화(아직 노드가 없을때)

	/*왜 참조 연산자','을 안쓰고 '->'를 쓰냐면,
	애초에 createList(List *lp)함수가 받는 인자가 포인터기때문에 포인터주소에 해당되는
	실제 구조체의 인자를 가리켜야하므로 -> 를 사용해야함 */

	return TRUE;
}

// addFirst()함수 - Node 를 하나 생성해 headpointer가 가리키는 첫 자리에 대입하게 함. (node 추가 함수)

BOOL addFirst(List* lp, int data) {
	Node* newp; // 노드 생성

	if (lp == NULL) { // *lp NULL check
		return FALSE;
	}

	newp = (Node*)malloc(sizeof(Node)); // 동적할당
	if (newp != NULL) {
		newp->data = data; // 새 노드에 데이터 저장
		newp->next = lp->head->next; // head포인터가 가리키던 첫 노드의 주소 연결
		lp->head->next = newp; //head포인터는 새 노드를 가리키도록 연결
		lp->size = lp->size + 1; // 관리 list 의 size 수 증가
		return TRUE;
	}
	else {
		return FALSE;
	}
}

BOOL addLast(List* lp, int data) {
	Node* newp; // 새 노드
	Node* btp; // tail노드 앞 노드

	if (lp == NULL) {
		return FALSE;
	}

	newp = (Node*)malloc(sizeof(Node));// 동적할당
	if (newp != NULL) {
		newp->data = data;
		newp->next = lp->tail; // tail이 가리키는 주소가 아니라, 그냥 tail의 주소 - addFirst함수와의 차이점
		//tail노드 앞 노드 검색
		//tail노드 앞에 새 노드 연결
		btp = lp->head; //btp를 첫 노드인 head노드로 설정
		while (btp->next != lp->tail) {
			btp = btp->next; //btp는 head의 주소, btp->next 는 head가 가리키는 노드의 주소
		}
		btp->next = newp; //btp가 tail전 노드가 됨
		++lp->size;
		return TRUE;
	}
	else {
		return FALSE;
	}
}

void displayList(List* lp) {
	Node* crnt;

	if (lp == NULL) {
		return;
	}
	crnt = lp->head->next; // 이렇게 해야 crnt = head Node가 됨.
	while (crnt != lp->tail) { //crnt->next 가 가리키는 곳부터 data가 있음.
		cout << crnt->data << endl;
		crnt = crnt->next; // 다음 노드로 넘겨주는 코드
	}
	cout << endl;
	return;
}
