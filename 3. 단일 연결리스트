// 단일 연결리스트 생성해보기 (creatList(List *lp))

#include<iostream>

using namespace std;


// 구조체, 노드 선언 라인

enum BOOL { FALSE, TRUE };

typedef struct _node Node; //형변환 - _node 구조체를 Node 라는 단어로 사용하겠다!
struct _node {
	int data;
	Node* next;
};

typedef struct _list {
	Node* head; // data, next를 가진 구조체
	Node* tail; // data, next를 가진 구조체
	int size; // Node 수
}List;



// 함수 선언 라인

BOOL createList(List *lp); // List구조체로 만들어지는 리스트의 주소를 받음
BOOL addFirst(List *lp, int data); // Node 생성 후 list에 추가하는 함수

int main() {
	

}

BOOL createList(List* lp) {
	if (lp == NULL) {   // lp포인터 NULL check - 주소가 있는건지 없는건지 확인
		return FALSE;
	}


	lp->head = (Node*)malloc(sizeof(Node)); // List구조체의 head 원소에 접근하면서 head Node 생성
	//malloc함수 특성상, 동적할당에 실패하면 NULL을 반환함, 따라서 실패했으면, FALSE를 반환하도록 해야함
	if (lp->head == NULL) {
		return FALSE;
	}
	lp->head = (Node*)malloc(sizeof(Node)); // tail Node 생성 (구조체 동적할당)
	if (lp->tail == NULL) {
		free(lp->head);
		return FALSE;
	}


	/*head tail 연결*/
	lp->head->next = lp->tail; // tail 주소를 head가 가리키도록 설정
	
	/*tail node의 포인터는 자기 자신을 가리키도록 설정*/
	lp->tail->next = lp->tail;

	lp->size = 0; // 연결리스트 크기 0 으로 초기화(아직 노드가 없을때)

	free(lp->head);
	free(lp->tail);

	/*왜 참조 연산자','을 안쓰고 '->'를 쓰냐면, 
	애초에 createList(List *lp)함수가 받는 인자가 포인터기때문에 포인터주소에 해당되는
	실제 구조체의 인자를 가리켜야하므로 -> 를 사용해야함 */

	return TRUE;
}

// addFirst()함수 - Node 를 하나 생성해 headpointer가 가리키는 첫 자리에 대입하게 함. (node 추가 함수)

BOOL addFirst(List* lp, int data) {
	Node* newp; // 노드 생성

	if (lp == NULL) { // *lp NULL check
		return FALSE;
	}
	
	newp = (Node*)malloc(sizeof(Node)); // 동적할당
	if (newp != NULL) {
		newp->data = data; // 새 노드에 데이터 저장
		newp->next = lp->head->next; // head포인터가 가리키던 첫 노드의 주소 연결
		lp->head->next = newp; //head포인터는 새 노드를 가리키도록 연결
		lp->size = lp->size + 1; // 관리 list 의 size 수 증가
		return TRUE;
	}
	else {
		return FALSE;
	}
